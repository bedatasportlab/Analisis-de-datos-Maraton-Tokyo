---
title: "Análisis Exploratorio de Datos. La Maratón de Tokyo 2025."
author:
  - "Alba Martínez de la Hermosa"
  - "Alonso González Romero"
  - "Daniel López Paredes"
date: "2025-10-16"
format: html
toc: true
toc-depth: 2
number-sections: true
lang: es
keywords: ["maratón", "análisis de datos", "Tokyo"]
abstract: "MODIFICAR."
---

# Importación de librerías. 

```{r}
#| warning: false

# Importación de todas las librerías usadas durante el informe y breve descripcion
library(readr) # Libreria para poder importar los datos desde un csv.
library(ggplot2) # Libreria para poder hacer gráficos.
library(DT) # Libreria para poder visualizar dataframes en qmd de manera interactiva.
library(hms) # Libreria para poder tratar datos referentes a horas, minutos y segundos.
library(dplyr) # Libreria para poder manipular dataframes.
library(tidyr) # Libreria para poder transformar dataframes.
library(e1071) # para skewness() y kurtosis()
library(stringr) # Para la limpieza de nombres del Dataframe.
library(knitr) # Para tablas bien formateadas
library(viridis) # Paletas de color para los gráficos.
library(plotly) # Para gráficas de mapas.
library(gapminder) # Usaremos este paquete para la lista de países estándar
library(patchwork) # para combinar gráficos ggplot2

```

# Introducción
El **maratón de Tokyo 2025** se celebró, en su 18ª edición, el domingo 2 de marzo de 2025. Esta edición forma parte de los World Marathon Majors y abrió la temporada 2025 de los grandes maratones internacionales. El recorrido atraviesa distintos puntos icónicos de la ciudad de Tokyo, estando su inicio frente al edificio del Gobierno Metropolitano y la línea de meta cerca de la estación Tokyo/Gyoko-dori Avenue. El maratón de Tokyo es un evento de gran participación, tanto de atletas de élite como de aficionados. 

En el presente documento se realizará un análisis exploratorio de datos (EDA) con el objetivo de extraer información relevante acerca de los resultados de los corredores que participaron en dicha prueba.

# Presentación y Descripción del Dataset
Los resultados del maratón de Tokyo han sido extraídos a través del siguiente [enlace](https://www.marathon.tokyo/2025/result). La extracción se ha realizado a través de técnicas de Web Scrapping con el objetivo de poder obtener datos relevantes referentes a los resultados de los corredores participantes.

## Importación del Dataset

A continuación, se realiza la correspondiente importación de los datos extraídos:

```{r}
resultadosTokyo2025 <- read_csv(
  "data/Maraton_Tokyo/marathon_tokyo_results_2025.csv",
  col_types = cols(
    BIB = col_integer(),
    Nombre = col_character(),
    Nacionalidad = col_character(),
    Genero = col_character(),
    Edad = col_integer(),
    tiempo_oficial = col_time(format = "%H:%M:%S"),
    parcial_5km = col_time(format = "%H:%M:%S"),
    parcial_10km = col_time(format = "%H:%M:%S"),
    parcial_15km = col_time(format = "%H:%M:%S"),
    parcial_20km = col_time(format = "%H:%M:%S"),
    medio_maraton = col_time(format = "%H:%M:%S"),
    parcial_25km = col_time(format = "%H:%M:%S"),
    parcial_30km = col_time(format = "%H:%M:%S"),
    parcial_35km = col_time(format = "%H:%M:%S"),
    parcial_40km = col_time(format = "%H:%M:%S")
  ),
  quote = "\""
)

# Transformacion a formato dataframe.
resultadosTokyo2025 <- as.data.frame(resultadosTokyo2025)
```


## Descripción del Dataset
El dataframe importado, *resultadosTokyo2025*, consta de las siguientes variables: 

| Variable       | Tipo            | Descripción                                        | Unidades      |
| -------------- | --------------- | -------------------------------------------------- | ------------- |
| BIB            | Numérica/Entero | Número de dorsal asignado al corredor, valor único | Número entero |
| Nombre         | Cadena de texto | Nombre y apellidos del corredor                    | Texto         |
| Nacionalidad   | Cadena de texto | País de procedencia del corredor                   | Texto         |
| Genero         | Categórica      | Género del corredor                                | Texto         |
| Edad           | Numérica/Entero | Edad del corredor                                  | Años          |
| tiempo_oficial | Tiempo          | Tiempo total oficial de la maratón (gross time)    | hh:mm:ss      |
| parcial_5km    | Tiempo          | Tiempo de paso en el km 5                          | hh:mm:ss      |
| parcial_10km   | Tiempo          | Tiempo de paso en el km 10                         | hh:mm:ss      |
| parcial_15km   | Tiempo          | Tiempo de paso en el km 15                         | hh:mm:ss      |
| parcial_20km   | Tiempo          | Tiempo de paso en el km 20                         | hh:mm:ss      |
| medio_maraton  | Tiempo          | Tiempo al paso del medio maratón (21,097 km)       | hh:mm:ss      |
| parcial_25km   | Tiempo          | Tiempo de paso en el km 25                         | hh:mm:ss      |
| parcial_30km   | Tiempo          | Tiempo de paso en el km 30                         | hh:mm:ss      |
| parcial_35km   | Tiempo          | Tiempo de paso en el km 35                         | hh:mm:ss      |
| parcial_40km   | Tiempo          | Tiempo de paso en el km 40                         | hh:mm:ss      |


*Nota: El gross time es el tiempo que tarda un corredor en terminar la maratón desde que se da el pistoletazo de salida, no desde que cruza la línea de inicio de la prueba*
 
## Lectura de una fila

Una vez que conocemos el significado de cada variable por separado, se va a proceder a la lectura de la primera fila del *dataframe* con el objetivo de mejorar la comprensión sobre el formato de los datos:

```{r}
# Lo visualizamos con la libreria DT porque es más interactiva a la hora de generar el documento qmd.
datatable(
  resultadosTokyo2025,
  options = list(
    pageLength = 1, # cuántas filas mostrar
    scrollX = TRUE, # habilita scroll horizontal si la fila es muy ancha
    dom = 't' # solo muestra la tabla sin paginación ni búsqueda
  ),
  rownames = FALSE # quitar número de fila en la tabla
)

```

Se puede observar al corredor **Tadese Takele**, de nacionalidad **Etíope**, que corrió la maratón con el dorsal **número 5**. Tadese completó la maratón a sus 22 años con un tiempo de **2 horas, 3 minutos y 23 segundos**, pudiendose observar sus tiempos de paso cada 5 kilómetros y en el punto de la media maratón. 

## Dimensiones del dataset

```{r}
filas <- nrow(resultadosTokyo2025)
columnas <- ncol(resultadosTokyo2025)
cat(
  "El dataframe resultadosTokyo2025 contiene",
  filas,
  "filas y",
  columnas,
  "columnas."
)
# Elimino el número de filas y columnas con el objetivo de no sobrecargar el environment.
rm(filas, columnas)
```

## Descripción estadística del DataFrame

En este apartado se calculan las estadísticas para comprobar qué datos es necesario limpiar y posteriormente poder hacer un análisis fiable.
```{r}
#Estadísticas de Edad
resumen_edad <- data.frame(
    Minimo = min(resultadosTokyo2025$Edad, na.rm = TRUE),
    Maximo = max(resultadosTokyo2025$Edad, na.rm = TRUE),
    Media = round(mean(resultadosTokyo2025$Edad, na.rm = TRUE),2),
    Nulos = sum(is.na(resultadosTokyo2025$Edad))
)
resumen_edad
```

```{r}
#Estadísticas tiempo
cols_tiempo <- c("tiempo_oficial", "parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

resultadosTokyo2025[cols_tiempo] <- lapply(resultadosTokyo2025[cols_tiempo], as_hms) #columnas a tipo hms

resumen_tiempos <- data.frame(
  Minimo = sapply(resultadosTokyo2025[cols_tiempo], min, na.rm = TRUE),
  Maximo = sapply(resultadosTokyo2025[cols_tiempo], max, na.rm = TRUE),
  Media  = sapply(resultadosTokyo2025[cols_tiempo], function(x) round(mean(x, na.rm = TRUE), 2)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos
```

```{r}
#Estadísticas tiempos en hms
resumen_tiempos_convertidos <- data.frame (
  Minimo_hms = resumen_tiempos$Minimo <- as_hms((resumen_tiempos$Minimo)),
  Maximo_hms = resumen_tiempos$Maximo <- as_hms((resumen_tiempos$Maximo)),
  Media_hms = resumen_tiempos$Media <- as_hms((resumen_tiempos$Media)),
  Nulos  = sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))
)
resumen_tiempos_convertidos
```

Gracias a la descripción estadística se ha comprobado que los datos de los tiempos y las edades son coherentes y se han podido observar qué parciales no tienen valores asociados. Cabe destacar que todos los deportistas que aparecen en el dataframe, aunque en algunos casos no estén registrados todos sus parciales, llevaron a término la prueba, ya que el total de valores faltantes que hay en la columna de tiempo oficial es 0.

## Limpieza de datos

### Datos faltantes

En esta sección se busca identificar cuáles son los tiempos parciales que faltan para cada corredor.
```{r}
#Filas con NA
filas_con_na <- resultadosTokyo2025[ rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
which(is.na(resultadosTokyo2025[cols_tiempo]), arr.ind = TRUE)

#Filas con NA en cada columna
filas_con_na <- resultadosTokyo2025[rowSums(is.na(resultadosTokyo2025[cols_tiempo])) > 0, ]
head(filas_con_na, 20)

filas_con_na <- as.data.frame(filas_con_na)
str(filas_con_na)
```

Antes de seguir trabajando sobre el dataframe, es conveniente hacer una copia para trabajar sobre la copia sin tocar los datos originales por los erroes que pueda haber. 

```{r}
df_trabajo <- resultadosTokyo2025
```
```{r}
cols_tiempo <- c("parcial_5km", "parcial_10km", "parcial_15km", "parcial_20km", "medio_maraton", "parcial_25km", "parcial_30km", "parcial_35km", "parcial_40km")

dist <- c(5, 10, 15, 20, 21.0975, 25, 30, 35, 40)

filas_con_na <- df_trabajo[rowSums(is.na(df_trabajo[, cols_tiempo])) > 0, ]
filas_con_na$n_na <- rowSums(is.na(filas_con_na[, cols_tiempo]))

head(filas_con_na[, c(cols_tiempo, "n_na")])
```

Habiendo identificado las filas con valores NA y la situacion de dichos valores en las columnas, se procede a valorar si a qué corredores se les va a estimar algún parcial o no. El criterio es el que aquí sigue:

Si una fila tiene 2 o más parciales sin tiempo registrado consecutivos no se considerará imputable ya que la falta de tan solo dos valores faltantes consecutivos implica un desconocimiento del desarrollo de la prueba durante 15 kilómetros. Asumir un ritmo constante durante 15 kilómetros en una disciplina de duración tan larga como la maratón en atletas amateur (son los que tienen los parciales sin registrar) y en el tramo central de la carrera es irreal.

De esta forma, solo se tendrían en cuenta para imputar aquellas filas cuyos parciales puedan calcularse con el tiempo inmediatamente anterior y/o posterior.

```{r}
filas_con_na$max_na_consec <- sapply(1:nrow(filas_con_na), function(i) {
  elems <- unlist(filas_con_na[i, cols_tiempo])
  na_vec <- is.na(elems)
  if(all(!na_vec)) return(0)
  max(rle(na_vec)$lengths[rle(na_vec)$values == TRUE])
})
```

```{r}
filas_con_na$clasificacion <- ifelse(
  filas_con_na$max_na_consec >= 2,
  "descartar",
  "imputable"
)
filas_con_na$descarte <- filas_con_na$clasificacion == "descartar"
filas_para_imputar <- filas_con_na[filas_con_na$descarte == FALSE, ]
```

Recogidos los valores que pueden imputarse se procede a destacar 4 casos distintos según cuál sea el parcial desconocido:

Si no está el parcial de 5km se debe tener en cuenta que el ritmo en el primer tramo de la maratón es en promedio un 5% más rápido que el ritmo de tramos posteriores.

Si el kilómetro 40 es el faltante, al hacer los cálculos hay que considerar que desde el parcial 35 hay 5km de distancia pero para la llegada a la meta hay 2km y 195m.
De igual manera, si no se sabe el tiempo de paso por la media maratón es preciso saber que desde el parcial del kilómetro 20 hay 1km y 96m de distancia y 3km 904m hasta el kilómetro 25.

El cuarto caso es el de un parcial que pueda calcularse con el tiempo de paso inmediatamente anterior y posterior a él.

```{r}
imputar_parciales <- function(tiempos, dist, cols_tiempo) {
  if (!inherits(tiempos, "hms")) tiempos <- hms::as_hms(tiempos)
  idx_medio <- which(cols_tiempo == "medio_maraton")
  
  for (i in seq_along(tiempos)) {
    if (i == idx_medio) next
    if (is.na(tiempos[i])) {
      
      prev_idx <- max(which(!is.na(tiempos[1:(i - 1)])), na.rm = TRUE)
      next_idx <- min(which(!is.na(tiempos[(i + 1):length(tiempos)])), na.rm = TRUE)
      if (is.finite(next_idx)) next_idx <- next_idx + i
      if (is.finite(prev_idx) && is.finite(next_idx)) {
        t_prev <- tiempos[prev_idx]
        t_next <- tiempos[next_idx]
        d_prev <- dist[prev_idx]
        d_next <- dist[next_idx]
        d_missing <- dist[i]
        tiempos[i] <- t_prev + (t_next - t_prev) * ((d_missing - d_prev) / (d_next - d_prev)) #interpolación lineal estándar
      }
    }
  }
  return(tiempos)
}
primera_imputacion <- as.data.frame(
  t(apply(filas_para_imputar[cols_tiempo], 1, imputar_parciales, dist = dist, cols_tiempo = cols_tiempo))
)
colnames(primera_imputacion) <- cols_tiempo
primera_imputacion[cols_tiempo] <-
  lapply(primera_imputacion[cols_tiempo], hms::as_hms)
```

```{r}
#Añadir a primera_imputacion la imputacion de medio_maraton

idx_20 <- which(cols_tiempo == "parcial_20km")
idx_media <- which(cols_tiempo == "medio_maraton")
idx_25 <- which(cols_tiempo == "parcial_25km")

filas_na <- which(is.na(primera_imputacion$medio_maraton))

d_20 <- dist[idx_20]
d_media <- dist[idx_media]
d_25 <- dist[idx_25]

primera_imputacion$medio_maraton[filas_na] <- hms::as_hms(
  (primera_imputacion$parcial_20km[filas_na] * (d_25 - d_media) +
     primera_imputacion$parcial_25km[filas_na] * (d_media - d_20)) / (d_25 - d_20)
)
```

```{r}
#Añadir a primera_imputacion la imputacion de parcial_5km

idx_5 <- which(cols_tiempo == "parcial_5km")
idx_10 <- which(cols_tiempo == "parcial_10km")

filas_na_5 <- which(is.na(primera_imputacion$parcial_5km))

d_5 <- dist[idx_5]
d_10 <- dist[idx_10]

factor_salida <- 0.95  # 5% más rápida

primera_imputacion$parcial_5km[filas_na_5] <- hms::as_hms(
  (primera_imputacion$parcial_10km[filas_na_5] - hms::as_hms(0)) * factor_salida * (d_5 / d_10)
)
```

```{r}
#Añadir a primera_imputacion la imputacion del parcial_40km

idx_35 <- which(cols_tiempo == "parcial_35km")
idx_40 <- which(cols_tiempo == "parcial_40km")
d_35 <- dist[idx_35]
d_40 <- dist[idx_40]

filas_na_40 <- which(is.na(primera_imputacion$parcial_40km))
primera_imputacion$parcial_40km[filas_na_40] <- hms::as_hms(
  primera_imputacion$parcial_35km[filas_na_40] +
    (primera_imputacion$parcial_35km[filas_na_40] - primera_imputacion$parcial_30km[filas_na_40]) *
    ((d_40 - d_35) / (d_35 - dist[idx_35 - 1]))
)
```

```{r}
redondear_hms <- function(x) {
  seg_total <- as.numeric(x)
  seg_total_rounded <- round(seg_total)
  hms::as_hms(seg_total_rounded)
}
primera_imputacion[cols_tiempo] <- lapply(
  primera_imputacion[cols_tiempo],
  redondear_hms
)
```

```{r}
df_trabajo[rownames(filas_para_imputar), cols_tiempo] <- primera_imputacion
resultadosTokyo2025 <- df_trabajo
```

### Valores únicos - datos duplicados

```{r}
cols_para_duplicados <- c(cols_tiempo, "BIB")
valores_unicos <- lapply(df_trabajo[cols_para_duplicados], unique)
valores_unicos
```

```{r}
n_unicos <- sapply(valores_unicos, length) #Valores únicos por columna
n_filas <- nrow(df_trabajo) # Número de filas total

for(col in names(n_unicos)){ # Comprobar si hay duplicados
  if(n_unicos[col] == n_filas){
    message(paste("Columna", col, ": Ningún valor duplicado"))
  } else {
    message(paste("Columna", col, "tiene duplicados"))
  }
}
```

En este apartado se ha comprobado que no hay ningún corredor duplicado y que en todos los parciales hay pocos valores duplicados, lo que es coherente con el formato de carrera de una maratón. Es raro que haya grupos de carrera grandes en una disciplina de tan larga duración y con participantes de niveles tan dispares.

```{r}
duplicados_df <- data.frame( # Crear un data frame vacío para guardar los duplicados
  columna = character(),
  valor = character(),
  frecuencia = integer(),
  stringsAsFactors = FALSE
)
for (col in cols_tiempo) { # Recorrer las columnas de tiempo
  freq <- table(df_trabajo[[col]])           # frecuencia de cada valor
  duplicados <- freq[freq > 1]               # solo los que aparecen más de una vez
  
  if (length(duplicados) > 0) {
    temp <- data.frame(
      columna = col,
      valor = names(duplicados),
      frecuencia = as.integer(duplicados),
      stringsAsFactors = FALSE
    )
    duplicados_df <- rbind(duplicados_df, temp)
  }
}
duplicados_df
```

```{r}
for(col in cols_tiempo){
  freq <- table(df_trabajo[[col]])  # cuenta cuántas veces aparece cada valor
  duplicados <- freq[freq > 1]               # filtra solo los que aparecen más de una vez
  if(length(duplicados) > 0){
    cat("\nColumna:", col, "\n")
    print(duplicados)
  } else {
    cat("\nColumna:", col, "→ Ningún duplicado\n")
  }
}
```

### Transformación de datos

### Comprobación de calidad antes del análisis

```{r}
sapply(resultadosTokyo2025[cols_tiempo], function(x) sum(is.na(x)))

resultadosTokyo2025$n_na_fila <- rowSums(is.na(resultadosTokyo2025[cols_tiempo]))
head(resultadosTokyo2025[, c("BIB", "n_na_fila")])
```

Los corredores cuyos tiempos parciales que se han quedado sin imputar no se van a eliminar del dataframe para poder seguir contando con su tiempo final en el análisis de esa variable. Para el análisis univariante de los tiempos parciales solamente se obviarán esas filas (las filas descartadas para la imputación han sido 9).

```{r}
cols_validar <- c("tiempo_oficial", cols_tiempo, "Edad")

resumen_calidad <- resultadosTokyo2025 %>%
  select(all_of(cols_validar)) %>%
  summarise(across(everything(), list(
    Minimo = ~if(is.numeric(.)) min(., na.rm = TRUE) else as_hms(min(., na.rm = TRUE)),
    Maximo = ~if(is.numeric(.)) max(., na.rm = TRUE) else as_hms(max(., na.rm = TRUE)),
    Media  = ~if(is.numeric(.)) mean(., na.rm = TRUE) else as_hms(mean(as.numeric(.), na.rm = TRUE))
  ), .names = "{.col}_{.fn}"))

resumen_calidad_tidy <- t(resumen_calidad)
colnames(resumen_calidad_tidy) <- "Valor"

resumen_calidad_tidy
```

# Análisis Univariante

En esta sección se realizará un análisis descriptivo completo de cada una de las variables del conjunto de datos por separado.

## DF temporal (borrar cuando esté lista la parte de Limpieza de Datos)

```{r}
resultadosTokyo2025 <- read_csv(
  "data/Maraton_Tokyo/marathon_tokyo_results_2025.csv",
  col_types = cols(
    BIB = col_integer(),
    Nombre = col_character(),
    Nacionalidad = col_character(),
    Genero = col_character(),
    Edad = col_integer(),
    tiempo_oficial = col_time(format = "%H:%M:%S"),
    parcial_5km = col_time(format = "%H:%M:%S"),
    parcial_10km = col_time(format = "%H:%M:%S"),
    parcial_15km = col_time(format = "%H:%M:%S"),
    parcial_20km = col_time(format = "%H:%M:%S"),
    medio_maraton = col_time(format = "%H:%M:%S"),
    parcial_25km = col_time(format = "%H:%M:%S"),
    parcial_30km = col_time(format = "%H:%M:%S"),
    parcial_35km = col_time(format = "%H:%M:%S"),
    parcial_40km = col_time(format = "%H:%M:%S")
  ),
  quote = "\""
)

# Transformacion a formato dataframe.
resultadosTokyo2025 <- as.data.frame(resultadosTokyo2025)
```

```{r}
df_seconds <- resultadosTokyo2025 %>%
  mutate(
    across(
      matches("^tiempo_oficial$|^parcial_\\d+km$|^medio_maraton$"),
      ~ as.numeric(.x)
    )
  )

# Vista previa
glimpse(df_seconds)
```

<!-- Exploración de variables individuales: distribuciones, estadísticos descriptivos, etc. -->

Bajo este análisis se examinará cada variable del conjunto de datos para resumir su distribución, principales características y tendencias. Este tipo de análisis se centra en **una sola variable a la vez**, sin tener en cuenta su relación con otras, y permite obtener una primera descripción general de los datos. A continuación se revisa cada variable del dataset para observar sus principales características estadísticas.

### Edad

Esta variable indica la **edad** de los corredores que participaron en la maratón. Se trata de una variable numérica discreta. Primero se examinán los principales estadísticos de centralización: media, moda y mediana

```{r}
# Fun. moda que devuelve el valor más frecuente (si hay empates devuelve el primero)
moda <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_real_)
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Estadísticos resumidos (redondeados)
edad_stats <- df_seconds %>%
  summarise(
    Total_valores = sum(!is.na(Edad)),
    Valores_faltantes = sum(is.na(Edad)),
    Media = round(mean(Edad, na.rm = TRUE), 2),
    Mediana = median(Edad, na.rm = TRUE),
    Moda = moda(Edad),
  )

datatable(
  edad_stats,
  options = list(dom = 't'),
  rownames = FALSE
)

```

<!-- Interpretación de los estadísticos de centralización -->
La edad media de los corredores que participaron en la maratón de Tokyo 2025 es de aproximadamente 46 años, con una mediana de 47 años y una moda de 50 años. Esto indica que la distribución de edades está muy ligeramente sesgada hacia edades mayores, ya que la media es menor que la mediana. La moda sugiere que la edad más común entre los corredores es de 50 años, lo que podría indicar una mayor participación de corredores en este rango de edad.

Representado de forma gráfica, en la siguiente figura se observa un histograma con línea de densidad.

```{r}
ggplot(df_seconds, aes(x = Edad)) +
  geom_histogram(aes(y = ..density..), binwidth=2, fill = "#90CAF9", color = "gray30") +
  geom_density(aes(y = ..density..), 
               fill = "#1976D2", alpha = 0.15) +
  labs(title = "Distribución de Edad",
       x = "Edad (años)", y = "Densidad") +
  theme_minimal(base_size = 12)
```

En esta gráfica se observa que la distribución de edades de los corredores es aproximadamente normal, con una ligera asimetría positiva (hacia la derecha). La mayoría de los corredores tienen edades comprendidas entre los 25 y 40 años, con un pico alrededor de los 30 años. La media, mediana y moda están bastante cercanas entre sí, lo que indica que la distribución es simétrica.

A continuación se presentan los estadísticos de dispersión y forma de la distribución de edades.

```{r}
edad_disp_forma <- df_seconds %>%
  summarise(
    Minimo = min(Edad, na.rm = TRUE),
    Maximo = max(Edad, na.rm = TRUE),
    Rango = max(Edad, na.rm = TRUE) - min(Edad, na.rm = TRUE),
    Varianza = round(var(Edad, na.rm = TRUE), 2),
    Desviación_Estandar = round(sd(Edad, na.rm = TRUE), 2),
    Desviacion_tipica = round(sqrt(var(Edad, na.rm = TRUE)), 2),
    Coeficiente_Variacion = round((sd(Edad, na.rm = TRUE) / mean(Edad, na.rm = TRUE)) * 100, 2),
    Asimetría = round(skewness(Edad, na.rm = TRUE), 2),
    Curtosis = round(kurtosis(Edad, na.rm = TRUE), 2)
  )

datatable(
  edad_disp_forma,
  options = list(dom = 't'),
  rownames = FALSE
)

```

<!-- Interpretación de los resultados de los estadísticos de dispersión -->

Las edades varían desde un mínimo de 18 años hasta un máximo de 84 años, con un rango total de 65 años. La varianza (122,64) y la desviación estándar (11,07) indican que hay una dispersión moderada en las edades de los corredores. El coeficiente de variación del 23,77% sugiere que la variabilidad relativa de las edades es considerable.

La asimetría negativa (-0,06) indica que la distribución de edades es ligeramente sesgada hacia la izquierda, aunque está muy cerca de cero, lo que sugiere una distribución casi simétrica. La curtosis (-0,58) indica que la distribución de edades es ligeramente más plana que una distribución normal, lo que sugiere que hay menos valores extremos en las edades de los corredores.

En la siguiente grafica se observa un boxplot que muestra la dispersión de las edades de los corredores.

```{r}
ggplot(df_seconds, aes(y = Edad)) +
  geom_boxplot(fill = "#90CAF9", color = "gray30", outlier.color = "red", outlier.size = 1.5) +
  labs(title = "Boxplot de Edad",
       y = "Edad (años)") +
  theme_minimal(base_size = 12)
```
El boxplot muestra que la mayoría de las edades de los corredores están concentradas entre aproximadamente 39 y 50 años, con algunos valores atípicos en ambos extremos. La mediana (línea dentro de la caja) está cerca del centro de la caja, lo que indica una distribución simétrica de las edades. Los bigotes del boxplot indican que no hay valores extremadamente alejados del rango intercuartílico, lo que sugiere una distribución relativamente homogénea de las edades.

## Género

### LIMPIEZA DE LA VARIABLE GENERO (ESTO VA EN LA PARTE I CUANDO ESTÉ LISTA)

Debido a que los datos han sido extraídos de una web japonesa, los valores de la variable *Genero* presentan un formato bilingüe, con caracteres tanto japoneses como ingleses, separados por el caracter */*. Para facilitar posteriores análisis y visualizaciones, se ha tomado la decisión de unificar esta variable a un único idioma, en este caso, el inglés. Una vez limpia, la convertimos a **factor**. Para ello: 

```{r}
resultadosTokyo2025 <- resultadosTokyo2025 %>%
  mutate(
    # Modificamos la columna 'Género'
    Genero = str_remove(Genero, "^.*／")
  )

resultadosTokyo2025$Genero <- as.factor(resultadosTokyo2025$Genero)
```

### Análisis Univariante(eliminar esta sub-subsección cuando la anterior pase a la parte I)

En esta sección se realiza un análisis descriptivo de la variable *Genero*. Para ello, vamos a comenzar inspeccionando las categorías de la variable y sus frecuencias, tanto absoluta (número de corredores) como relativa (porcentaje del total). 

```{r}
tabla_frecuencias_genero <- resultadosTokyo2025 %>%
  count(Genero, name = "Frecuencia_Absoluta") %>%
  mutate(
    Porcentaje = Frecuencia_Absoluta / sum(Frecuencia_Absoluta) * 100
  ) %>%
  arrange(desc(Frecuencia_Absoluta))


kable(
  tabla_frecuencias_genero,
  col.names = c("Género", "Nº de Corredores", "Porcentaje (%)"),
  digits = c(0, 0, 2),
  caption = "Tabla: Distribución de participantes por género."
)
```

Se puede observar que existen 3 categorías con la siguiente participación: 

- **Men**: 
- **Women**
- **Non-Binary**

A continuación vamos a graficar la información obtenida en la tabla de frecuencia a través de un gráfico de barras. 

```{r}
ggplot(tabla_frecuencias_genero, aes(x = reorder(Genero, -Frecuencia_Absoluta), y = Frecuencia_Absoluta, fill = Genero)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(
    aes(label = scales::comma(Frecuencia_Absoluta)), 
    vjust = -0.5, 
    size = 3.5,
    color = "black" 
  ) +
  
  scale_fill_viridis_d() + 
  
  # Títulos, subtítulos y etiquetas de los ejes
  labs(
    title = "Distribución de Participantes por Género",
    subtitle = "Maratón de Tokyo | 02-03-2025",
    x = "Género",
    y = "Número de Corredores"
  ) +
  
  # Tema limpio y ajuste de eje para dar espacio a las etiquetas
  theme_minimal(base_size = 14) + # Aumenté un poco el tamaño base de la letra
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  theme(
    plot.title = element_text(face = "bold", size = 18), # Título en negrita y más grande
    plot.subtitle = element_text(size = 12, color = "gray30") # Subtítulo más sutil
  )
```

Por lo tanto podemos observar que la composición de la maratón muestra que casi **tres de cada cuatro corredores eran hombres**. 

```{r}
rm(tabla_frecuencias_genero)
```

## Nacionalidad

### Limpieza de la variable Nacionalidad. (poner luego en la parte correspondiente)

Para realizar la limpieza de la variable nacionalidad, veamos primero en una tabla los posibles valores que toma: 

```{r}

conteo_paises <- resultadosTokyo2025 %>%
   count(Nacionalidad, sort = TRUE, name = "Numero_Corredores")

# Lo visualizamos con la libreria DT porque es más interactiva a la hora de generar el documento qmd. Arreglar
datatable(
  conteo_paises,
  options = list(
    pageLength = 10,
    scrollX = TRUE,
  rownames = FALSE, # Mantiene la eliminación del número de fila
  colnames = c("País", "Número de Corredores")
)
```

Se peude observar que no existen países con el nombre duplicado (es decir, varios nombres para el mismo país). Aunque existen algunos paises que, si se quisiera hacer un análisis posterior con los nombres de las nacionalidades (para crear mapas por ejemplo), deberían modificar su nombre a un formato estándar en inglés. Además, podemos observar que hay algunos corredores con el país "-", estos deberían convertirse en valores NA. Puesto que son corredores sin ningún tipo de país asociado.

Para ello, vamos a crear una nueva variable en nuestro conjunto de datos que se relacione con el país con el nombre ya estandarizado, *Pais_Estandarizado*. 

```{r}

resultadosTokyo2025 <- resultadosTokyo2025 %>%
  mutate(
    # Primero, manejamos el caso del guion para que no interfiera
    Nacionalidad = na_if(Nacionalidad, "-"),
    
    # Ahora, creamos la nueva columna estandarizada
    Pais_Estandarizado = case_when(
      Nacionalidad == "日本" ~ "Japan",
      Nacionalidad == "PR OF CHINA" ~ "China",
      Nacionalidad == "CHINESE TAIPEI" ~ "Taiwan",
      Nacionalidad == "GREAT BRITAIN & N.I." ~ "United Kingdom",
      Nacionalidad == "HONG KONG, CHINA" ~ "Hong Kong",
      Nacionalidad == "KOREA" ~ "Korea, South",
      Nacionalidad == "DPR OF KOREA" ~ "Korea, North",
      Nacionalidad == "F Y REP. OF MACEDONIA" ~ "Macedonia",
      Nacionalidad == "SLOVAK REPUBLIC" ~ "Slovakia",
      Nacionalidad == "ISLAMIC REPUBLIC OF IRAN" ~ "Iran",
      Nacionalidad == "MACAO" ~ "Macau",
      Nacionalidad == "SAINT KITTS AND NEVIS" ~ "Saint Kitts and Nevis",
      Nacionalidad == "BAHAMAS" ~ "Bahamas, The",
      Nacionalidad == "REPUBLIC Of YEMEN" ~ "Yemen",
      Nacionalidad == "UNITED STATES" ~ "United States", # Usar el nombre completo suele ser más compatible
      
      # Para todos los demás países los ponemos en el formato minúsculas con la primera letra en mayúsculas.
      TRUE ~ str_to_title(Nacionalidad)
    )
  )

conteo_paises_limpios <- resultadosTokyo2025 %>%
  count(Pais_Estandarizado, sort = TRUE)

```

Observamos que, en principio, los errores están completamente corregidos. Para ver si los nuevos nombres estandarizados están correctamente, vamos a cruzar los países recién creados con...

```{r}
df <- read.csv("https://raw.githubusercontent.com/plotly/datasets/master/2014_world_gdp_with_codes.csv")

paises_validos <- df %>%
  distinct(COUNTRY) %>%
  # Renombramos la columna para que coincida con la nuestra y poder hacer el join
  rename(Pais_Estandarizado = COUNTRY)


paises_problematicos <- resultadosTokyo2025 %>%
  filter(!is.na(Pais_Estandarizado)) %>% # Ignoramos los NA que puedan existir
  distinct(Pais_Estandarizado) %>%
  anti_join(paises_validos, by = "Pais_Estandarizado")

```


Una vez realizado, creamos una nueva variable llamada *CODE_PLOTLY* que contendrá el código de cada país según este dataframe subido: 

```{r}

resultadosTokyo2025 <- resultadosTokyo2025 %>%
  left_join(
    df %>% select(COUNTRY, CODE),  
    by = c("Pais_Estandarizado" = "COUNTRY")  
  )

```

### Análisis Univariante (eliminar esta sub-subsección cuando la anterior pase a la parte I)

```{r}

frecuencia_paises <- resultadosTokyo2025 %>%
  count(Pais_Estandarizado, CODE, name = "corredores", sort = TRUE)

fig <- plot_ly(frecuencia_paises, type='choropleth', locations=frecuencia_paises$CODE, z=frecuencia_paises$corredores, text=frecuencia_paises$COUNTRY, colorscale="Blues")

fig
```

En este mapa se pueden observar los países y su

### Tiempo Oficial

En el caso de las variables de timepos, se realizará el análisis con las columnas transformadas a segundos pero reflejando los resultados en formato horas, minutos y segundos para una mejor interpretación. Esta transformación implica que la varible es numérica continua. Como en las variables anteriores, se comenzará con los estadísticos de centralización.

```{r}

# Estadísticos resumidos (redondeados)
tiempo_stats <- df_seconds %>%
  summarise(
    Total_valores = sum(!is.na(tiempo_oficial)),
    Valores_faltantes = sum(is.na(tiempo_oficial)),
    Media = round(mean(tiempo_oficial, na.rm = TRUE), 2),
    Mediana = median(tiempo_oficial, na.rm = TRUE),
    Moda = moda(tiempo_oficial),
  )

# Convertir a hms para mejor interpretación
tiempo_stats <- tiempo_stats %>%
  mutate(
    Media = as_hms(Media),
    Mediana = as_hms(Mediana),
    Moda = as_hms(Moda)
  )

datatable(
  tiempo_stats,
  options = list(dom = 't'),
  rownames = FALSE
)
```

<!-- Interpretación de los estadísticos de centralización -->
La media del tiempo oficial de los corredores que participaron en la maratón de Tokyo 2025 es de aproximadamente 4 horas, 40 minutos y 23 segundos, con una mediana de 4 horas, 36 minutos y 13 segundos. Esto indica que la distribución de los tiempos está sesgada positivamente, ya que la media es mayor que la mediana, es decir, hay corredores con tiempos significativamente más altos que elevan la media. La moda sugiere que el tiempo más común entre los corredores es de 4 horas, 15 minutos y 30 segundos.

Representado de forma gráfica, en la siguiente figura se observa un histograma con línea de densidad.

```{r}

# Convierte a hms para mejor interpretación

ggplot(df_seconds, aes(x = tiempo_oficial)) +
  geom_histogram(aes(y = ..density..), binwidth=500, fill = "#90CAF9", color = "gray30") +
  geom_density(aes(y = ..density..), 
               fill = "#1976D2", alpha = 0.15) +
  scale_x_continuous(
    breaks = seq(0, 21600, by = 3600), # cada 30 minutos
    labels = function(x) as_hms(x)      # convierte a hms para etiquetas
  ) +
  labs(title = "Distribución del Tiempo Oficial",
       x = "Tiempo Oficial (hh:mm:ss)", y = "Densidad") +
  theme_minimal(base_size = 12)
  
```

En esta gráfica se observa que la distribución de los tiempos oficiales de los corredores es asimétrica positivamente (hacia la derecha). La mayoría de los corredores tienen tiempos comprendidos entre 3 horas y 30 minutos y 5 horas, con un pico alrededor de las 4 horas.

A continuación se presentan los estadísticos de dispersión y forma de la distribución de tiempos oficiales.

```{r}
tiempo_disp_forma <- df_seconds %>%
  summarise(
    Minimo = as_hms(min(tiempo_oficial, na.rm = TRUE)),
    Maximo = as_hms(max(tiempo_oficial, na.rm = TRUE)),
    Rango = as_hms(max(tiempo_oficial, na.rm = TRUE) - min(tiempo_oficial, na.rm = TRUE)),
    Varianza = round(var(tiempo_oficial, na.rm = TRUE), 2),
    Desviación_Estandar = round(sd(tiempo_oficial, na.rm = TRUE), 2),
    Coeficiente_Variacion = round((sd(tiempo_oficial, na.rm = TRUE) / mean(tiempo_oficial, na.rm = TRUE)) * 100, 2),
    Asimetría = round(skewness(tiempo_oficial, na.rm = TRUE), 2),
    Curtosis = round(kurtosis(tiempo_oficial, na.rm = TRUE), 2)
  )

datatable(
  tiempo_disp_forma,
  options = list(dom = 't'),
  rownames = FALSE
)
```

<!-- Interpretación de los resultados de los estadísticos de dispersión -->
El rango de 4 horas, 56 minutos y 55 segundos indica una amplia variabilidad en los tiempos oficiales de los corredores. La desviación estándar de 3898.73	(~1 hora y 5 minutos) sugiere que los tiempos suelen oscilar alrededor de ±1 h de la media, lo que implica cierta variabilidad, pero no excesiva.. El coeficiente de variación del 23.77% indica que la variabilidad relativa de los tiempos oficiales es considerable.

La asimetría positiva (0.15) indica que la distribución de los tiempos oficiales está ligeramente sesgada hacia la derecha, lo que significa que hay más corredores con tiempos superiores a la media. La curtosis (-0.87) indica que la distribución de los tiempos oficiales es más plana que una distribución normal, lo que sugiere que hay menos valores extremos en los tiempos oficiales de los corredores. 

### Tiempos Parciales

### Nivel de los atletas

```{r}
clasificar_atletas_masc <- function(resultadosTokyo2025, genero_col = Genero, tiempo_col = tiempo_oficial) {
  resultadosTokyo2025 %>%
    mutate(
      Genero_raw = tolower(trimws(as.character({{genero_col}}))),
      Genero = case_when(
        Genero_raw %in% c("women") ~ "F",
        Genero_raw %in% c("men")   ~ "M",
        TRUE ~ NA_character_
      ),
      tiempo_hms = as_hms({{tiempo_col}}),
      categoria = case_when(
        Genero == "M" & tiempo_hms < as_hms("02:17:00") ~ "Élite",
        Genero == "M" & tiempo_hms < as_hms("02:30:00") ~ "Alto nivel",
        Genero == "M" & tiempo_hms < as_hms("03:00:00") ~ "Muy entrenado",
        Genero == "M" & tiempo_hms < as_hms("03:30:00") ~ "Moderadamente entrenado",
        Genero == "M" & tiempo_hms >= as_hms("03:30:00") ~ "Principiante",
        TRUE ~ "No élite"
      )
    ) %>%
    select(-Genero_raw)
}
```

```{r}
clasificar_atletas_fem <- function(resultadosTokyo2025, genero_col = Genero, tiempo_col = tiempo_oficial) {
  resultadosTokyo2025 %>%
    mutate(
      Genero_raw = tolower(trimws(as.character({{genero_col}}))),
      Genero = case_when(
        Genero_raw %in% c("women") ~ "F",
        Genero_raw %in% c("men")   ~ "M",
        TRUE ~ NA_character_
      ),
      tiempo_hms = as_hms({{tiempo_col}}),
      categoria = case_when(
        #mujeres
        Genero == "F" & tiempo_hms < as_hms("02:43:00") ~ "Élite",
        Genero == "F" & tiempo_hms < as_hms("03:00:00") ~ "Alto nivel",
        Genero == "F" & tiempo_hms < as_hms("03:30:00") ~ "Muy entrenada",
        Genero == "F" & tiempo_hms < as_hms("04:00:00") ~ "Moderadamente entrenada",
        Genero == "F" & tiempo_hms >= as_hms("04:00:00") ~ "Principiante",
      )
    ) %>%
    select(-Genero_raw)
}
```

```{r}
resultados_clasificados_masc <- clasificar_atletas_masc(resultadosTokyo2025)
head(resultados_clasificados)
```

```{r}
resultados_clasificados_fem <- clasificar_atletas_fem(resultadosTokyo2025)
head(resultados_clasificados)
```

## Análisis Bivariante y Multivariante

<!-- Relación entre variables, correlaciones, visualizaciones conjuntas, etc. -->

Tabla de doble entrada para edad y tiempo oficial

```{r}
tabla_doble_masc <- table(resultados_clasificados_masc$Edad, resultados_clasificados_masc$categoria)
```

```{r}
tabla_doble_fem <- table(resultados_clasificados_fem$Edad, resultados_clasificados_fem$categoria)
```

## Identificación de Patrones y Formulación de Preguntas

<!-- Detección de tendencias, patrones interesantes y planteamiento de preguntas para análisis futuros. -->
**Posibles preguntas:**

*Conociendo el ritmo:*

1. ¿En qué momento o momentos hay un cambio notable en el ritmo de los atletas?

2. ¿Hay algún cambio que sea común a todos los atletas independientemente del nivel?
  Puede indicar irregularidad del terreno, cambio en los elementos ambientales, presencia de público...

3. ¿Qué estrategia de carrera indica ese cambio de ritmo? 
  (Positiva (disminuye el tiempo según avanza la carrera)/negativa(aumenta el tiempo)/even pace(igual)/parabólica(primeros y últimos km más rápidos que los centrales))

4. ¿Qué factores psicofisiológicos están detrás de los cambios de ritmo?

5. ¿Se pueden identificar perfiles de corredores según cuándo se cambie el ritmo? ¿Según la estrategia que se utilice?

6. ¿Qué relación hay entre la estrategia (variación o no del ritmo en los parciales) y el tiempo final? 
  ¿Qué estrategias se repiten más en los mejores y peores tiempos finales?

7. ¿Qué relación hay entre los procesos piscofisiológicos y la estrategia de carrera?

9. ¿Qué relación hay entre los facotres ambientales y la estrategia? Crear perfil de maratón.

10. En un mismo recorrido y para un atleta del mismo nivel, ¿la estrategia puede ser distinta según el tipo de competición que sea? (Major, campeonato del mundo, JJOO...)

11. ¿Hay relación entre el sexo y la estrategia? ¿A qué podría deberse?

*La carrera en números:*

1. ¿Cuántos atletas bajaron de 2h10? ¿2h30? ¿3h00?

2. ¿Qué porcentaje de atletas llevó x ritmo?

3. ¿A cuánto tiempo y porcentaje de tiempo se quedaron los mejores tiempos masculino y femenino del récord del mundo?

4. ¿Qué nacionalidad tuvo el mejor rendimiento?

5. ¿Alguna marca entra en el top10 histórico?

6. ¿Cuál ha sido el lapso de tiempo al entrar en meta entre los tres primeros?

7. ¿Cuántos atletas olímpicos/internacionales han participado?


## Conclusiones

<!-- Resumen de hallazgos principales y posibles líneas de investigación. -->